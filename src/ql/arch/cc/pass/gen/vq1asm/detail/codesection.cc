#include "codesection.h"
#include "options.h"

#include "ql/version.h"

#include <iomanip>
#include <ios>

namespace ql {
namespace arch {
namespace cc {
namespace pass {
namespace gen {
namespace vq1asm {
namespace detail {


CodeSection::CodeSection(OperandContext &operandContext)
    : operandContext(operandContext) {
}

void CodeSection::showCodeSoFar() {
    // provide context to help finding reason. FIXME: limit # lines
    QL_EOUT("Code so far:\n" << codeSection.str());
}

void CodeSection::emitProgramHeader(const Str &progName) {
    // emit program header
    codeSection << std::left;    // assumed by cs.emit()
    codeSection << "# Program: '" << progName << "'" << std::endl;   // NB: put on top so it shows up in internal CC logging
    codeSection << "# CC_BACKEND_VERSION " << CC_BACKEND_VERSION_STRING << std::endl;
    codeSection << "# OPENQL_VERSION " << OPENQL_VERSION_STRING << std::endl;
    codeSection << "# Note:    generated by OpenQL Central Controller backend" << std::endl;
    codeSection << "#" << std::endl;
}

Int CodeSection::creg2reg(const ir::Reference &ref) {
    auto reg = operandContext.convert_creg_reference(ref);
    if(reg >= NUM_CREGS) {
        QL_INPUT_ERROR("register index " << reg << " exceeds maximum");
    }
    return reg;
};

UInt CodeSection::dest_reg(const ir::ExpressionRef &lhs) {
    return creg2reg(*lhs->as_reference());
};


/************************************************************************\
| Some helpers to ease nice assembly formatting
\************************************************************************/

// FIXME: assure space between fields!
// FIXME: make comment output depend on verboseCode

// FIXME: merge with next function
void CodeSection::emit(const Str &labelOrComment, const Str &instr) {
    if (labelOrComment.empty()) {                           // no label
        codeSection << "                " << instr << std::endl;
    } else if (labelOrComment.length() < 16) {              // label fits before instr
        codeSection << std::setw(16) << labelOrComment << std::setw(16) << instr << std::endl;
    } else if (instr.empty()) {                             // no instr
        codeSection << labelOrComment << std::endl;
    } else {
        codeSection << labelOrComment << std::endl << "                " << instr << std::endl;
    }
}


// @param   labelOrSel      label must include trailing ":"
// @param   comment         must include leading "#"
void CodeSection::emit(const Str &labelOrSel, const Str &instr, const Str &ops, const Str &comment) {
    codeSection << std::setw(16) << labelOrSel << std::setw(16) << instr << std::setw(36) << ops << comment << std::endl;
}

void CodeSection::emit(Int slot, const Str &instr, const Str &ops, const Str &comment) {
    emit(QL_SS2S("[" << slot << "]"), instr, ops, comment);
}


} // namespace detail
} // namespace vq1asm
} // namespace gen
} // namespace pass
} // namespace cc
} // namespace arch
} // namespace ql
